<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meathill HSM Documentation</title>

  <!-- 加载 TailwindCSS 及其 Typography 插件 -->
  <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
</head>
<body class="bg-gray-50 text-slate-900 font-sans antialiased">
  <!-- 顶部导航条 -->
  <header class="bg-white border-b border-gray-200">
    <div class="max-w-4xl mx-auto px-6 py-4 flex items-center justify-between">
      <h1 class="text-xl font-bold text-indigo-600">Meathill HSM</h1>
      <a href="https://github.com/meathill/hsm" target="_blank" class="text-sm font-medium text-gray-500 hover:text-gray-900 transition-colors">
        GitHub Source
      </a>
    </div>
  </header>

  <!-- 内容区 -->
  <main class="max-w-4xl mx-auto px-6 py-12">
    <article class="prose prose-slate prose-indigo lg:prose-lg max-w-none bg-white p-8 md:p-12 rounded-2xl shadow-sm border border-gray-100">
      <h1>Meathill HSM</h1>
<p><a href="https://github.com/meathill/hsm/actions/workflows/ci.yml"><img src="https://github.com/meathill/hsm/actions/workflows/ci.yml/badge.svg" alt="CI"></a></p>
<p>软件定义的密钥管理系统 (Hardware Security Module)，基于 Cloudflare Worker + KV 实现。</p>
<h2>功能特性</h2>
<ul>
<li>安全存储客户密钥</li>
<li>信封加密 (Envelope Encryption)</li>
<li>密钥分片设计，增强安全性</li>
<li>HMAC-SHA256 存储索引混淆</li>
<li>AES-GCM-256 AEAD 加密防篡改</li>
<li><strong>零信任设计 (Zero-Trust)</strong>：服务端无法解密用户数据</li>
<li><strong>无感跨域直连</strong>：原生支持 CORS，前端直传直取，彻底摆脱后端中转</li>
</ul>
<h2>为什么你的数据在这里绝对安全？</h2>
<p>传统的存储方案常常需要你信任服务提供商不偷看你的数据。但 Meathill HSM 采用 <strong>“零信任” (Zero-Trust)</strong> 的密码学设计，从数学上保证了即使服务端被攻破，或者服务提供商存在主观恶意，你的数据也完全无法被解密或篡改：</p>
<ol>
<li><strong>拿不到完整的钥匙</strong>：你的数据受 KEK 加密，而 KEK 由服务端的 <code>CF_SECRET_PART</code> (Part A) 和你自己在客户端持有的 <code>X-HSM-Secret</code> (Part B) 共同派生生成。服务端不保存 Part B，因此服务端<strong>永远</strong>凑不齐完整的解密钥匙。</li>
<li><strong>拿走了数据也没用</strong>：就算有人黑进了 Cloudflare KV 数据库并拖库，里面存的只是一堆完全随机的乱码数据，在没有你的 <code>X-HSM-Secret</code> 的情况下，这些加密数据几乎不可能被暴力破解。</li>
<li><strong>想篡改/覆盖/删除你的数据？做梦</strong>：系统使用 AES-GCM-256 AEAD 进行底层加密，这不仅保证内容的保密，还会验证数据的“完整性”。任何人试图覆盖或者删除你的数据时，系统都会先用请求中附带的密钥进行一次后台解密尝试。如果解密失败（身份/密钥不符），请求直接报错 403 被拦截。</li>
<li><strong>连你存了什么键名都不知道</strong>：你存的路径（<code>path</code>）在数据库里被 HMAC-SHA256 混淆处理了。即便查看数据库，也只能看到一长串哈希值，无法逆向推测出你原本存的是什么路径业务名。</li>
</ol>
<h2>如何在前端（Web 环境）直接使用？</h2>
<p>为了让全流程更加安全透明，HSM 服务原生放开了所有 <strong>CORS 跨域限制</strong> 并支持 <code>OPTIONS</code> 预检请求。这意味着你可以直接在浏览器的前端代码中（如 React, Vue, Vanilla JS）向 HSM 发起请求存取数据，<strong>无需经过你自己的后端服务器中转</strong>，从而杜绝了因为中间商泄露 <code>X-HSM-Secret</code> 的可能性。</p>
<h3>前端直连示例 (Fetch API)</h3>
<p><strong>存储数据</strong></p>
<pre><code class="language-javascript">async function saveMySecret() {
  const response = await fetch(&#39;https://&lt;your-hsm-worker-url&gt;/keys/my-app/user-1/token&#39;, {
    method: &#39;PUT&#39;,
    headers: {
      &#39;Content-Type&#39;: &#39;application/json&#39;,
      &#39;X-HSM-Secret&#39;: &#39;my-super-secret-client-key&#39; // 唯有你知道的秘密
    },
    body: JSON.stringify({ value: &#39;the-data-i-want-to-protect&#39; })
  });

  if (response.ok) {
    console.log(&#39;数据安全入库！&#39;);
  }
}
</code></pre>
<p><strong>获取数据</strong></p>
<pre><code class="language-javascript">async function getMySecret() {
  const response = await fetch(&#39;https://&lt;your-hsm-worker-url&gt;/keys/my-app/user-1/token&#39;, {
    method: &#39;GET&#39;,
    headers: {
      &#39;X-HSM-Secret&#39;: &#39;my-super-secret-client-key&#39; // 用同一把钥匙解密
    }
  });

  const result = await response.json();
  if (result.success) {
    console.log(&#39;取得解密后的数据：&#39;, result.data.value);
  }
}
</code></pre>
<p><strong>修改/覆盖数据</strong>
修改数据和“存储数据”调用的是同一个 <code>PUT</code> 接口，但安全机制要求你必须提供<strong>之前存入时相同的 <code>X-HSM-Secret</code></strong>，否则覆盖操作会被直接拒绝（403 Forbidden）。</p>
<pre><code class="language-javascript">async function updateMySecret() {
  const response = await fetch(&#39;https://&lt;your-hsm-worker-url&gt;/keys/my-app/user-1/token&#39;, {
    method: &#39;PUT&#39;,
    headers: {
      &#39;Content-Type&#39;: &#39;application/json&#39;,
      &#39;X-HSM-Secret&#39;: &#39;my-super-secret-client-key&#39; // 必须与原先存储时的密钥相同
    },
    body: JSON.stringify({ value: &#39;my-new-updated-data&#39; })
  });

  if (response.ok) {
    console.log(&#39;数据成功更新！&#39;);
  } else {
    console.error(&#39;更新失败，可能是密钥错误（无权修改）&#39;);
  }
}
</code></pre>
<p><strong>删除数据</strong>
同样，删除操作也需要你提交正确的 <code>X-HSM-Secret</code>。</p>
<pre><code class="language-javascript">async function deleteMySecret() {
  const response = await fetch(&#39;https://&lt;your-hsm-worker-url&gt;/keys/my-app/user-1/token&#39;, {
    method: &#39;DELETE&#39;,
    headers: {
      &#39;X-HSM-Secret&#39;: &#39;my-super-secret-client-key&#39; // 必须与原先存储时的密钥相同
    }
  });

  if (response.ok) {
    console.log(&#39;数据已安全销毁！&#39;);
  }
}
</code></pre>
<p>由于我们限制了单次存储的值长度不得超过 <strong>8192</strong> 字符，您可以放心地将各种 Token、隐私配置、或是小型的加密通信秘钥直接存入。</p>
<h2>运行环境</h2>
<ul>
<li>Cloudflare Worker + KV</li>
</ul>
<h2>API 接口</h2>
<h3>存储密钥</h3>
<pre><code class="language-http">PUT /keys/:path
Content-Type: application/json
X-HSM-Secret: &lt;调用方密钥&gt;

{
  &quot;value&quot;: &quot;my-secret-key-value&quot;
}
</code></pre>
<h3>获取密钥</h3>
<pre><code class="language-http">GET /keys/:path
X-HSM-Secret: &lt;调用方密钥&gt;
</code></pre>
<h3>删除密钥</h3>
<pre><code class="language-http">DELETE /keys/:path
X-HSM-Secret: &lt;调用方密钥&gt;
</code></pre>
<h2>安全设计</h2>
<h3>密钥分片</h3>
<p>KEK（Key Encryption Key）通过 HKDF 从以下部分派生：</p>
<ul>
<li><strong>Part A</strong>：HSM 服务的密钥，存储在 Cloudflare Worker 环境变量 <code>CF_SECRET_PART</code></li>
<li><strong>Part B</strong>：调用方的密钥，通过 <code>X-HSM-Secret</code> 请求头传递</li>
<li><strong>Salt</strong>：每次加密随机生成</li>
</ul>
<p><strong>安全保证</strong>：</p>
<ul>
<li>HSM 服务不知道调用方的密钥 → 无法单独解密</li>
<li>调用方不知道 HSM 服务的密钥 → 拿到 KV 数据也无法解密</li>
<li>只有通过 HSM 服务，且提供正确的 <code>X-HSM-Secret</code>，才能解密</li>
</ul>
<h3>信封加密</h3>
<ol>
<li>生成随机 DEK（Data Encryption Key）</li>
<li>使用 DEK + AES-GCM-256 加密数据</li>
<li>使用 KEK + AES-GCM-256 加密 DEK</li>
<li>存储加密后的 DEK 和数据</li>
</ol>
<h3>AAD（附加认证数据）</h3>
<p>使用密钥路径作为 AAD，防止密钥互换攻击。</p>
<h2>环境变量</h2>
<table>
<thead>
<tr>
<th>变量名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>INDEX_SECRET</code></td>
<td>HMAC 索引混淆密钥</td>
</tr>
<tr>
<td><code>CF_SECRET_PART</code></td>
<td>HSM 服务密钥（Part A）</td>
</tr>
</tbody></table>
<h2>请求头</h2>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>X-HSM-Secret</code></td>
<td>调用方密钥（Part B）</td>
</tr>
</tbody></table>
<h2>开发</h2>
<pre><code class="language-bash"># 安装依赖
pnpm install

# 运行测试
pnpm test

# 本地开发
pnpm dev

# 部署
pnpm deploy
</code></pre>
<h2>测试覆盖</h2>
<p>当前测试覆盖包括：</p>
<ul>
<li>编码工具 (Base64, UTF-8)</li>
<li>HMAC-SHA256 索引生成</li>
<li>HKDF 密钥派生</li>
<li>AES-GCM 加解密</li>
<li>信封加密完整流程</li>
<li>API 端点集成测试</li>
</ul>

    </article>
  </main>
</body>
</html>